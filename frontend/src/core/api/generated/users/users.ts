/**
 * Generated by orval v8.0.0 üç∫
 * Do not edit manually.
 * Dentizy API
 * API Documentation untuk Sistem Manajemen Klinik Gigi
 * OpenAPI spec version: 1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  ChangePasswordDto,
  CreateUserDto,
  PasswordChangeResponseDto,
  ResetPasswordDto,
  UpdateUserDto,
  UserResponseDto,
  UsersControllerFindAllParams,
  UsersControllerGetRecentUsersParams
} from '../../model';

import { customInstance } from '../../../service/http/axiosInstance';


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * Hanya KEPALA_KLINIK yang dapat membuat user baru
 * @summary Buat user baru
 */
export type usersControllerCreateResponse201 = {
  data: UserResponseDto
  status: 201
}

export type usersControllerCreateResponse400 = {
  data: void
  status: 400
}

export type usersControllerCreateResponse401 = {
  data: void
  status: 401
}

export type usersControllerCreateResponse403 = {
  data: void
  status: 403
}

export type usersControllerCreateResponse409 = {
  data: void
  status: 409
}
    
export type usersControllerCreateResponseSuccess = (usersControllerCreateResponse201) & {
  headers: Headers;
};
export type usersControllerCreateResponseError = (usersControllerCreateResponse400 | usersControllerCreateResponse401 | usersControllerCreateResponse403 | usersControllerCreateResponse409) & {
  headers: Headers;
};

export type usersControllerCreateResponse = (usersControllerCreateResponseSuccess | usersControllerCreateResponseError)

export const getUsersControllerCreateUrl = () => {


  

  return `/users`
}

export const usersControllerCreate = async (createUserDto: CreateUserDto, options?: RequestInit): Promise<usersControllerCreateResponse> => {
  
  return customInstance<usersControllerCreateResponse>(getUsersControllerCreateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createUserDto,)
  }
);}




export const getUsersControllerCreateMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersControllerCreate>>, TError,{data: CreateUserDto}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof usersControllerCreate>>, TError,{data: CreateUserDto}, TContext> => {

const mutationKey = ['usersControllerCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};



      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof usersControllerCreate>>, {data: CreateUserDto}> = (props) => {
          const {data} = props ?? {};

          return  usersControllerCreate(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type UsersControllerCreateMutationResult = NonNullable<Awaited<ReturnType<typeof usersControllerCreate>>>
    export type UsersControllerCreateMutationBody = CreateUserDto
    export type UsersControllerCreateMutationError = void

    /**
 * @summary Buat user baru
 */
export const useUsersControllerCreate = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersControllerCreate>>, TError,{data: CreateUserDto}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof usersControllerCreate>>,
        TError,
        {data: CreateUserDto},
        TContext
      > => {
      return useMutation(getUsersControllerCreateMutationOptions(options), queryClient);
    }
    /**
 * Mendukung filter: role, search (nama/username), isActive
 * @summary Daftar semua user dengan pagination dan filter
 */
export type usersControllerFindAllResponse200 = {
  data: void
  status: 200
}

export type usersControllerFindAllResponse401 = {
  data: void
  status: 401
}

export type usersControllerFindAllResponse403 = {
  data: void
  status: 403
}
    
export type usersControllerFindAllResponseSuccess = (usersControllerFindAllResponse200) & {
  headers: Headers;
};
export type usersControllerFindAllResponseError = (usersControllerFindAllResponse401 | usersControllerFindAllResponse403) & {
  headers: Headers;
};

export type usersControllerFindAllResponse = (usersControllerFindAllResponseSuccess | usersControllerFindAllResponseError)

export const getUsersControllerFindAllUrl = (params?: UsersControllerFindAllParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/users?${stringifiedParams}` : `/users`
}

export const usersControllerFindAll = async (params?: UsersControllerFindAllParams, options?: RequestInit): Promise<usersControllerFindAllResponse> => {
  
  return customInstance<usersControllerFindAllResponse>(getUsersControllerFindAllUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getUsersControllerFindAllQueryKey = (params?: UsersControllerFindAllParams,) => {
    return [
    `/users`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getUsersControllerFindAllQueryOptions = <TData = Awaited<ReturnType<typeof usersControllerFindAll>>, TError = void>(params?: UsersControllerFindAllParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersControllerFindAll>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};


  const queryKey =  queryOptions?.queryKey ?? getUsersControllerFindAllQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof usersControllerFindAll>>> = ({ signal }) => usersControllerFindAll(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof usersControllerFindAll>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type UsersControllerFindAllQueryResult = NonNullable<Awaited<ReturnType<typeof usersControllerFindAll>>>
export type UsersControllerFindAllQueryError = void


export function useUsersControllerFindAll<TData = Awaited<ReturnType<typeof usersControllerFindAll>>, TError = void>(
 params: undefined |  UsersControllerFindAllParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersControllerFindAll>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersControllerFindAll>>,
          TError,
          Awaited<ReturnType<typeof usersControllerFindAll>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUsersControllerFindAll<TData = Awaited<ReturnType<typeof usersControllerFindAll>>, TError = void>(
 params?: UsersControllerFindAllParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersControllerFindAll>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersControllerFindAll>>,
          TError,
          Awaited<ReturnType<typeof usersControllerFindAll>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUsersControllerFindAll<TData = Awaited<ReturnType<typeof usersControllerFindAll>>, TError = void>(
 params?: UsersControllerFindAllParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersControllerFindAll>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Daftar semua user dengan pagination dan filter
 */

export function useUsersControllerFindAll<TData = Awaited<ReturnType<typeof usersControllerFindAll>>, TError = void>(
 params?: UsersControllerFindAllParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersControllerFindAll>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUsersControllerFindAllQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * @summary Statistik user untuk dashboard
 */
export type usersControllerGetStatisticsResponse200 = {
  data: unknown
  status: 200
}

export type usersControllerGetStatisticsResponse401 = {
  data: void
  status: 401
}

export type usersControllerGetStatisticsResponse403 = {
  data: void
  status: 403
}
    
export type usersControllerGetStatisticsResponseSuccess = (usersControllerGetStatisticsResponse200) & {
  headers: Headers;
};
export type usersControllerGetStatisticsResponseError = (usersControllerGetStatisticsResponse401 | usersControllerGetStatisticsResponse403) & {
  headers: Headers;
};

export type usersControllerGetStatisticsResponse = (usersControllerGetStatisticsResponseSuccess | usersControllerGetStatisticsResponseError)

export const getUsersControllerGetStatisticsUrl = () => {


  

  return `/users/statistics`
}

export const usersControllerGetStatistics = async ( options?: RequestInit): Promise<usersControllerGetStatisticsResponse> => {
  
  return customInstance<usersControllerGetStatisticsResponse>(getUsersControllerGetStatisticsUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getUsersControllerGetStatisticsQueryKey = () => {
    return [
    `/users/statistics`
    ] as const;
    }

    
export const getUsersControllerGetStatisticsQueryOptions = <TData = Awaited<ReturnType<typeof usersControllerGetStatistics>>, TError = void>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersControllerGetStatistics>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};


  const queryKey =  queryOptions?.queryKey ?? getUsersControllerGetStatisticsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof usersControllerGetStatistics>>> = ({ signal }) => usersControllerGetStatistics({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof usersControllerGetStatistics>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type UsersControllerGetStatisticsQueryResult = NonNullable<Awaited<ReturnType<typeof usersControllerGetStatistics>>>
export type UsersControllerGetStatisticsQueryError = void


export function useUsersControllerGetStatistics<TData = Awaited<ReturnType<typeof usersControllerGetStatistics>>, TError = void>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersControllerGetStatistics>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersControllerGetStatistics>>,
          TError,
          Awaited<ReturnType<typeof usersControllerGetStatistics>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUsersControllerGetStatistics<TData = Awaited<ReturnType<typeof usersControllerGetStatistics>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersControllerGetStatistics>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersControllerGetStatistics>>,
          TError,
          Awaited<ReturnType<typeof usersControllerGetStatistics>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUsersControllerGetStatistics<TData = Awaited<ReturnType<typeof usersControllerGetStatistics>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersControllerGetStatistics>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Statistik user untuk dashboard
 */

export function useUsersControllerGetStatistics<TData = Awaited<ReturnType<typeof usersControllerGetStatistics>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersControllerGetStatistics>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUsersControllerGetStatisticsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * @summary User yang baru dibuat
 */
export type usersControllerGetRecentUsersResponse200 = {
  data: UserResponseDto[]
  status: 200
}

export type usersControllerGetRecentUsersResponse401 = {
  data: void
  status: 401
}

export type usersControllerGetRecentUsersResponse403 = {
  data: void
  status: 403
}
    
export type usersControllerGetRecentUsersResponseSuccess = (usersControllerGetRecentUsersResponse200) & {
  headers: Headers;
};
export type usersControllerGetRecentUsersResponseError = (usersControllerGetRecentUsersResponse401 | usersControllerGetRecentUsersResponse403) & {
  headers: Headers;
};

export type usersControllerGetRecentUsersResponse = (usersControllerGetRecentUsersResponseSuccess | usersControllerGetRecentUsersResponseError)

export const getUsersControllerGetRecentUsersUrl = (params?: UsersControllerGetRecentUsersParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/users/recent?${stringifiedParams}` : `/users/recent`
}

export const usersControllerGetRecentUsers = async (params?: UsersControllerGetRecentUsersParams, options?: RequestInit): Promise<usersControllerGetRecentUsersResponse> => {
  
  return customInstance<usersControllerGetRecentUsersResponse>(getUsersControllerGetRecentUsersUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getUsersControllerGetRecentUsersQueryKey = (params?: UsersControllerGetRecentUsersParams,) => {
    return [
    `/users/recent`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getUsersControllerGetRecentUsersQueryOptions = <TData = Awaited<ReturnType<typeof usersControllerGetRecentUsers>>, TError = void>(params?: UsersControllerGetRecentUsersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersControllerGetRecentUsers>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};


  const queryKey =  queryOptions?.queryKey ?? getUsersControllerGetRecentUsersQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof usersControllerGetRecentUsers>>> = ({ signal }) => usersControllerGetRecentUsers(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof usersControllerGetRecentUsers>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type UsersControllerGetRecentUsersQueryResult = NonNullable<Awaited<ReturnType<typeof usersControllerGetRecentUsers>>>
export type UsersControllerGetRecentUsersQueryError = void


export function useUsersControllerGetRecentUsers<TData = Awaited<ReturnType<typeof usersControllerGetRecentUsers>>, TError = void>(
 params: undefined |  UsersControllerGetRecentUsersParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersControllerGetRecentUsers>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersControllerGetRecentUsers>>,
          TError,
          Awaited<ReturnType<typeof usersControllerGetRecentUsers>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUsersControllerGetRecentUsers<TData = Awaited<ReturnType<typeof usersControllerGetRecentUsers>>, TError = void>(
 params?: UsersControllerGetRecentUsersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersControllerGetRecentUsers>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersControllerGetRecentUsers>>,
          TError,
          Awaited<ReturnType<typeof usersControllerGetRecentUsers>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUsersControllerGetRecentUsers<TData = Awaited<ReturnType<typeof usersControllerGetRecentUsers>>, TError = void>(
 params?: UsersControllerGetRecentUsersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersControllerGetRecentUsers>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary User yang baru dibuat
 */

export function useUsersControllerGetRecentUsers<TData = Awaited<ReturnType<typeof usersControllerGetRecentUsers>>, TError = void>(
 params?: UsersControllerGetRecentUsersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersControllerGetRecentUsers>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUsersControllerGetRecentUsersQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * @summary Cek ketersediaan username
 */
export type usersControllerCheckUsernameResponse200 = {
  data: unknown
  status: 200
}

export type usersControllerCheckUsernameResponse401 = {
  data: void
  status: 401
}

export type usersControllerCheckUsernameResponse403 = {
  data: void
  status: 403
}
    
export type usersControllerCheckUsernameResponseSuccess = (usersControllerCheckUsernameResponse200) & {
  headers: Headers;
};
export type usersControllerCheckUsernameResponseError = (usersControllerCheckUsernameResponse401 | usersControllerCheckUsernameResponse403) & {
  headers: Headers;
};

export type usersControllerCheckUsernameResponse = (usersControllerCheckUsernameResponseSuccess | usersControllerCheckUsernameResponseError)

export const getUsersControllerCheckUsernameUrl = (username: string,) => {


  

  return `/users/check-username/${username}`
}

export const usersControllerCheckUsername = async (username: string, options?: RequestInit): Promise<usersControllerCheckUsernameResponse> => {
  
  return customInstance<usersControllerCheckUsernameResponse>(getUsersControllerCheckUsernameUrl(username),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getUsersControllerCheckUsernameQueryKey = (username?: string,) => {
    return [
    `/users/check-username/${username}`
    ] as const;
    }

    
export const getUsersControllerCheckUsernameQueryOptions = <TData = Awaited<ReturnType<typeof usersControllerCheckUsername>>, TError = void>(username: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersControllerCheckUsername>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};


  const queryKey =  queryOptions?.queryKey ?? getUsersControllerCheckUsernameQueryKey(username);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof usersControllerCheckUsername>>> = ({ signal }) => usersControllerCheckUsername(username, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(username), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof usersControllerCheckUsername>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type UsersControllerCheckUsernameQueryResult = NonNullable<Awaited<ReturnType<typeof usersControllerCheckUsername>>>
export type UsersControllerCheckUsernameQueryError = void


export function useUsersControllerCheckUsername<TData = Awaited<ReturnType<typeof usersControllerCheckUsername>>, TError = void>(
 username: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersControllerCheckUsername>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersControllerCheckUsername>>,
          TError,
          Awaited<ReturnType<typeof usersControllerCheckUsername>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUsersControllerCheckUsername<TData = Awaited<ReturnType<typeof usersControllerCheckUsername>>, TError = void>(
 username: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersControllerCheckUsername>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersControllerCheckUsername>>,
          TError,
          Awaited<ReturnType<typeof usersControllerCheckUsername>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUsersControllerCheckUsername<TData = Awaited<ReturnType<typeof usersControllerCheckUsername>>, TError = void>(
 username: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersControllerCheckUsername>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Cek ketersediaan username
 */

export function useUsersControllerCheckUsername<TData = Awaited<ReturnType<typeof usersControllerCheckUsername>>, TError = void>(
 username: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersControllerCheckUsername>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUsersControllerCheckUsernameQueryOptions(username,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * @summary Detail user by ID
 */
export type usersControllerFindOneResponse200 = {
  data: UserResponseDto
  status: 200
}

export type usersControllerFindOneResponse401 = {
  data: void
  status: 401
}

export type usersControllerFindOneResponse403 = {
  data: void
  status: 403
}

export type usersControllerFindOneResponse404 = {
  data: void
  status: 404
}
    
export type usersControllerFindOneResponseSuccess = (usersControllerFindOneResponse200) & {
  headers: Headers;
};
export type usersControllerFindOneResponseError = (usersControllerFindOneResponse401 | usersControllerFindOneResponse403 | usersControllerFindOneResponse404) & {
  headers: Headers;
};

export type usersControllerFindOneResponse = (usersControllerFindOneResponseSuccess | usersControllerFindOneResponseError)

export const getUsersControllerFindOneUrl = (id: string,) => {


  

  return `/users/${id}`
}

export const usersControllerFindOne = async (id: string, options?: RequestInit): Promise<usersControllerFindOneResponse> => {
  
  return customInstance<usersControllerFindOneResponse>(getUsersControllerFindOneUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getUsersControllerFindOneQueryKey = (id?: string,) => {
    return [
    `/users/${id}`
    ] as const;
    }

    
export const getUsersControllerFindOneQueryOptions = <TData = Awaited<ReturnType<typeof usersControllerFindOne>>, TError = void>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersControllerFindOne>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};


  const queryKey =  queryOptions?.queryKey ?? getUsersControllerFindOneQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof usersControllerFindOne>>> = ({ signal }) => usersControllerFindOne(id, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof usersControllerFindOne>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type UsersControllerFindOneQueryResult = NonNullable<Awaited<ReturnType<typeof usersControllerFindOne>>>
export type UsersControllerFindOneQueryError = void


export function useUsersControllerFindOne<TData = Awaited<ReturnType<typeof usersControllerFindOne>>, TError = void>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersControllerFindOne>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersControllerFindOne>>,
          TError,
          Awaited<ReturnType<typeof usersControllerFindOne>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUsersControllerFindOne<TData = Awaited<ReturnType<typeof usersControllerFindOne>>, TError = void>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersControllerFindOne>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersControllerFindOne>>,
          TError,
          Awaited<ReturnType<typeof usersControllerFindOne>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUsersControllerFindOne<TData = Awaited<ReturnType<typeof usersControllerFindOne>>, TError = void>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersControllerFindOne>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Detail user by ID
 */

export function useUsersControllerFindOne<TData = Awaited<ReturnType<typeof usersControllerFindOne>>, TError = void>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersControllerFindOne>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUsersControllerFindOneQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * Hanya KEPALA_KLINIK yang dapat update. Field opsional: nama_lengkap, username, roles
 * @summary Update data user
 */
export type usersControllerUpdateResponse200 = {
  data: UserResponseDto
  status: 200
}

export type usersControllerUpdateResponse401 = {
  data: void
  status: 401
}

export type usersControllerUpdateResponse403 = {
  data: void
  status: 403
}

export type usersControllerUpdateResponse404 = {
  data: void
  status: 404
}

export type usersControllerUpdateResponse409 = {
  data: void
  status: 409
}
    
export type usersControllerUpdateResponseSuccess = (usersControllerUpdateResponse200) & {
  headers: Headers;
};
export type usersControllerUpdateResponseError = (usersControllerUpdateResponse401 | usersControllerUpdateResponse403 | usersControllerUpdateResponse404 | usersControllerUpdateResponse409) & {
  headers: Headers;
};

export type usersControllerUpdateResponse = (usersControllerUpdateResponseSuccess | usersControllerUpdateResponseError)

export const getUsersControllerUpdateUrl = (id: string,) => {


  

  return `/users/${id}`
}

export const usersControllerUpdate = async (id: string,
    updateUserDto: UpdateUserDto, options?: RequestInit): Promise<usersControllerUpdateResponse> => {
  
  return customInstance<usersControllerUpdateResponse>(getUsersControllerUpdateUrl(id),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      updateUserDto,)
  }
);}




export const getUsersControllerUpdateMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersControllerUpdate>>, TError,{id: string;data: UpdateUserDto}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof usersControllerUpdate>>, TError,{id: string;data: UpdateUserDto}, TContext> => {

const mutationKey = ['usersControllerUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};



      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof usersControllerUpdate>>, {id: string;data: UpdateUserDto}> = (props) => {
          const {id,data} = props ?? {};

          return  usersControllerUpdate(id,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type UsersControllerUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof usersControllerUpdate>>>
    export type UsersControllerUpdateMutationBody = UpdateUserDto
    export type UsersControllerUpdateMutationError = void

    /**
 * @summary Update data user
 */
export const useUsersControllerUpdate = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersControllerUpdate>>, TError,{id: string;data: UpdateUserDto}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof usersControllerUpdate>>,
        TError,
        {id: string;data: UpdateUserDto},
        TContext
      > => {
      return useMutation(getUsersControllerUpdateMutationOptions(options), queryClient);
    }
    /**
 * Hanya KEPALA_KLINIK yang dapat menghapus user
 * @summary Hapus user
 */
export type usersControllerRemoveResponse200 = {
  data: unknown
  status: 200
}

export type usersControllerRemoveResponse401 = {
  data: void
  status: 401
}

export type usersControllerRemoveResponse403 = {
  data: void
  status: 403
}

export type usersControllerRemoveResponse404 = {
  data: void
  status: 404
}
    
export type usersControllerRemoveResponseSuccess = (usersControllerRemoveResponse200) & {
  headers: Headers;
};
export type usersControllerRemoveResponseError = (usersControllerRemoveResponse401 | usersControllerRemoveResponse403 | usersControllerRemoveResponse404) & {
  headers: Headers;
};

export type usersControllerRemoveResponse = (usersControllerRemoveResponseSuccess | usersControllerRemoveResponseError)

export const getUsersControllerRemoveUrl = (id: string,) => {


  

  return `/users/${id}`
}

export const usersControllerRemove = async (id: string, options?: RequestInit): Promise<usersControllerRemoveResponse> => {
  
  return customInstance<usersControllerRemoveResponse>(getUsersControllerRemoveUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}




export const getUsersControllerRemoveMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersControllerRemove>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof usersControllerRemove>>, TError,{id: string}, TContext> => {

const mutationKey = ['usersControllerRemove'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};



      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof usersControllerRemove>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  usersControllerRemove(id,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type UsersControllerRemoveMutationResult = NonNullable<Awaited<ReturnType<typeof usersControllerRemove>>>
    
    export type UsersControllerRemoveMutationError = void

    /**
 * @summary Hapus user
 */
export const useUsersControllerRemove = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersControllerRemove>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof usersControllerRemove>>,
        TError,
        {id: string},
        TContext
      > => {
      return useMutation(getUsersControllerRemoveMutationOptions(options), queryClient);
    }
    /**
 * User yang terautentikasi dapat mengganti password mereka sendiri. Memerlukan password lama, password baru, dan konfirmasi.
 * @summary Ganti password sendiri
 */
export type usersControllerChangePasswordResponse200 = {
  data: PasswordChangeResponseDto
  status: 200
}

export type usersControllerChangePasswordResponse400 = {
  data: void
  status: 400
}

export type usersControllerChangePasswordResponse401 = {
  data: void
  status: 401
}

export type usersControllerChangePasswordResponse403 = {
  data: void
  status: 403
}
    
export type usersControllerChangePasswordResponseSuccess = (usersControllerChangePasswordResponse200) & {
  headers: Headers;
};
export type usersControllerChangePasswordResponseError = (usersControllerChangePasswordResponse400 | usersControllerChangePasswordResponse401 | usersControllerChangePasswordResponse403) & {
  headers: Headers;
};

export type usersControllerChangePasswordResponse = (usersControllerChangePasswordResponseSuccess | usersControllerChangePasswordResponseError)

export const getUsersControllerChangePasswordUrl = () => {


  

  return `/users/change-password`
}

export const usersControllerChangePassword = async (changePasswordDto: ChangePasswordDto, options?: RequestInit): Promise<usersControllerChangePasswordResponse> => {
  
  return customInstance<usersControllerChangePasswordResponse>(getUsersControllerChangePasswordUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      changePasswordDto,)
  }
);}




export const getUsersControllerChangePasswordMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersControllerChangePassword>>, TError,{data: ChangePasswordDto}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof usersControllerChangePassword>>, TError,{data: ChangePasswordDto}, TContext> => {

const mutationKey = ['usersControllerChangePassword'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};



      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof usersControllerChangePassword>>, {data: ChangePasswordDto}> = (props) => {
          const {data} = props ?? {};

          return  usersControllerChangePassword(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type UsersControllerChangePasswordMutationResult = NonNullable<Awaited<ReturnType<typeof usersControllerChangePassword>>>
    export type UsersControllerChangePasswordMutationBody = ChangePasswordDto
    export type UsersControllerChangePasswordMutationError = void

    /**
 * @summary Ganti password sendiri
 */
export const useUsersControllerChangePassword = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersControllerChangePassword>>, TError,{data: ChangePasswordDto}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof usersControllerChangePassword>>,
        TError,
        {data: ChangePasswordDto},
        TContext
      > => {
      return useMutation(getUsersControllerChangePasswordMutationOptions(options), queryClient);
    }
    /**
 * Hanya KEPALA_KLINIK yang dapat mereset password user lain. Tidak memerlukan password lama.
 * @summary Reset password user (admin)
 */
export type usersControllerResetPasswordResponse200 = {
  data: PasswordChangeResponseDto
  status: 200
}

export type usersControllerResetPasswordResponse401 = {
  data: void
  status: 401
}

export type usersControllerResetPasswordResponse403 = {
  data: void
  status: 403
}

export type usersControllerResetPasswordResponse404 = {
  data: void
  status: 404
}
    
export type usersControllerResetPasswordResponseSuccess = (usersControllerResetPasswordResponse200) & {
  headers: Headers;
};
export type usersControllerResetPasswordResponseError = (usersControllerResetPasswordResponse401 | usersControllerResetPasswordResponse403 | usersControllerResetPasswordResponse404) & {
  headers: Headers;
};

export type usersControllerResetPasswordResponse = (usersControllerResetPasswordResponseSuccess | usersControllerResetPasswordResponseError)

export const getUsersControllerResetPasswordUrl = (id: string,) => {


  

  return `/users/${id}/reset-password`
}

export const usersControllerResetPassword = async (id: string,
    resetPasswordDto: ResetPasswordDto, options?: RequestInit): Promise<usersControllerResetPasswordResponse> => {
  
  return customInstance<usersControllerResetPasswordResponse>(getUsersControllerResetPasswordUrl(id),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      resetPasswordDto,)
  }
);}




export const getUsersControllerResetPasswordMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersControllerResetPassword>>, TError,{id: string;data: ResetPasswordDto}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof usersControllerResetPassword>>, TError,{id: string;data: ResetPasswordDto}, TContext> => {

const mutationKey = ['usersControllerResetPassword'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};



      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof usersControllerResetPassword>>, {id: string;data: ResetPasswordDto}> = (props) => {
          const {id,data} = props ?? {};

          return  usersControllerResetPassword(id,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type UsersControllerResetPasswordMutationResult = NonNullable<Awaited<ReturnType<typeof usersControllerResetPassword>>>
    export type UsersControllerResetPasswordMutationBody = ResetPasswordDto
    export type UsersControllerResetPasswordMutationError = void

    /**
 * @summary Reset password user (admin)
 */
export const useUsersControllerResetPassword = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersControllerResetPassword>>, TError,{id: string;data: ResetPasswordDto}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof usersControllerResetPassword>>,
        TError,
        {id: string;data: ResetPasswordDto},
        TContext
      > => {
      return useMutation(getUsersControllerResetPasswordMutationOptions(options), queryClient);
    }
    /**
 * Hanya KEPALA_KLINIK yang dapat generate password temporary untuk user. Password akan di-generate otomatis dan memenuhi kebijakan keamanan.
 * @summary Generate password temporary
 */
export type usersControllerGenerateTempPasswordResponse200 = {
  data: unknown
  status: 200
}

export type usersControllerGenerateTempPasswordResponse401 = {
  data: void
  status: 401
}

export type usersControllerGenerateTempPasswordResponse403 = {
  data: void
  status: 403
}

export type usersControllerGenerateTempPasswordResponse404 = {
  data: void
  status: 404
}
    
export type usersControllerGenerateTempPasswordResponseSuccess = (usersControllerGenerateTempPasswordResponse200) & {
  headers: Headers;
};
export type usersControllerGenerateTempPasswordResponseError = (usersControllerGenerateTempPasswordResponse401 | usersControllerGenerateTempPasswordResponse403 | usersControllerGenerateTempPasswordResponse404) & {
  headers: Headers;
};

export type usersControllerGenerateTempPasswordResponse = (usersControllerGenerateTempPasswordResponseSuccess | usersControllerGenerateTempPasswordResponseError)

export const getUsersControllerGenerateTempPasswordUrl = (id: string,) => {


  

  return `/users/${id}/generate-temp-password`
}

export const usersControllerGenerateTempPassword = async (id: string, options?: RequestInit): Promise<usersControllerGenerateTempPasswordResponse> => {
  
  return customInstance<usersControllerGenerateTempPasswordResponse>(getUsersControllerGenerateTempPasswordUrl(id),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}




export const getUsersControllerGenerateTempPasswordMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersControllerGenerateTempPassword>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof usersControllerGenerateTempPassword>>, TError,{id: string}, TContext> => {

const mutationKey = ['usersControllerGenerateTempPassword'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};



      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof usersControllerGenerateTempPassword>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  usersControllerGenerateTempPassword(id,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type UsersControllerGenerateTempPasswordMutationResult = NonNullable<Awaited<ReturnType<typeof usersControllerGenerateTempPassword>>>
    
    export type UsersControllerGenerateTempPasswordMutationError = void

    /**
 * @summary Generate password temporary
 */
export const useUsersControllerGenerateTempPassword = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersControllerGenerateTempPassword>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof usersControllerGenerateTempPassword>>,
        TError,
        {id: string},
        TContext
      > => {
      return useMutation(getUsersControllerGenerateTempPasswordMutationOptions(options), queryClient);
    }
    